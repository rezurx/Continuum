#!/usr/bin/env bash
# Continuum Auto-Setup Script
# Usage: continuum [init|start|status|help]

MEM_FILE=".claude-memory.json"
HOOK_FILE=".git/hooks/post-commit"
CONTINUUM_HOOK="$HOME/dev/continuum/hooks/post-commit"

function show_help() {
  cat <<EOT
Continuum - Auto-setup for any project

Commands:
  continuum            Auto-setup current folder (init + hooks + summary)
  continuum init       Initialize memory only
  continuum start      Start API server for this project
  continuum status     Show current project status
  continuum import     Import existing project documentation
  continuum help       Show this help

After setup, use 'mem' commands normally:
  mem phase "description"
  mem log "notes" --type note
  mem show --summary
EOT
}

function check_for_import() {
  # Only check if memory is empty (new project)
  local history_count=$(~/dev/continuum/bin/mem show | jq '.session_history | length' 2>/dev/null || echo "0")
  
  if [ "$history_count" -le 1 ]; then
    # Look for common documentation files
    local doc_files=()
    for pattern in "PROJECT.md" "README.md" "TODO.md" "PROGRESS.md" "CHANGELOG.md" "NOTES.md" "progress.md" "todo.md"; do
      if [ -f "$pattern" ]; then
        doc_files+=("$pattern")
      fi
    done
    
    if [ ${#doc_files[@]} -gt 0 ]; then
      echo ""
      echo "üìã Found project documentation files:"
      for file in "${doc_files[@]}"; do
        echo "   - $file"
      done
      echo ""
      echo "üí° Would you like to import this context into Continuum?"
      echo "   This will help AI agents understand your project immediately."
      echo ""
      echo "1) Yes - Show me the import instructions"
      echo "2) No  - Skip import and continue"
      echo ""
      read -p "Choice (1/2): " choice
      echo ""
      
      case "$choice" in
        1|y|yes|Y|Yes)
          echo "ü§ñ Starting automatic import..."
          echo ""
          
          # Start API server in background if not running
          if ! curl -s http://localhost:8000/health >/dev/null 2>&1; then
            echo "üöÄ Starting Continuum API server..."
            start_server_background "${doc_files[@]}"
          else
            echo "‚úÖ API server already running"
            perform_import "${doc_files[@]}"
          fi
          ;;
        2|n|no|N|No|"")
          echo "‚è≠Ô∏è  Skipping import. You can run 'continuum import' later."
          echo ""
          ;;
        *)
          echo "‚è≠Ô∏è  Invalid choice. Skipping import."
          echo ""
          ;;
      esac
    fi
  fi
}

function import_docs() {
  echo "ü§ñ Starting smart import process..."
  echo ""
  echo "üìñ Instructions for your AI assistant:"
  echo ""
  echo "1. Start the Continuum API server:"
  echo "   continuum start &"
  echo ""
  echo "2. Use this prompt:"
  echo "   \"Please read all documentation files in this project and extract:"
  echo "   - Current project phase/status"
  echo "   - Completed features and decisions" 
  echo "   - Pending tasks and next steps"
  echo "   - Key technical decisions made"
  echo ""
  echo "   Then import this context using the Continuum API:"
  echo "   - POST /phase to set current phase"
  echo "   - POST /log to add completed items (type: 'imported')"
  echo "   - POST /next to add pending tasks"
  echo ""
  echo "   After import, confirm the context with GET /summary\""
  echo ""
  echo "3. Once imported, you can archive/delete the original files"
  echo ""
}

function start_server_background() {
  local doc_files=("$@")
  
  # Check if virtual env exists, create if not
  if [ ! -d "continuum-env" ]; then
    echo "üì¶ Creating virtual environment..."
    python3 -m venv continuum-env >/dev/null 2>&1
    source continuum-env/bin/activate
    pip install -q fastapi uvicorn >/dev/null 2>&1
  fi
  
  echo "üåê Starting API server in background..."
  # Start server in background and capture PID
  (source continuum-env/bin/activate && python ~/dev/continuum/server.py >/dev/null 2>&1) &
  local server_pid=$!
  
  # Wait for server to start
  echo "‚è≥ Waiting for server to start..."
  local attempts=0
  while [ $attempts -lt 10 ]; do
    if curl -s http://localhost:8000/health >/dev/null 2>&1; then
      echo "‚úÖ Server started successfully"
      break
    fi
    sleep 1
    attempts=$((attempts + 1))
  done
  
  if [ $attempts -eq 10 ]; then
    echo "‚ùå Server failed to start. Please run 'continuum start' manually."
    return 1
  fi
  
  # Now perform the import
  perform_import "${doc_files[@]}"
  
  # Stop the background server
  kill $server_pid 2>/dev/null
  echo "üõë Background server stopped"
}

function perform_import() {
  local doc_files=("$@")
  
  echo "üìñ Reading and parsing documentation files..."
  
  # Simple parsing of common documentation patterns
  local phase=""
  local completed=()
  local todos=()
  local decisions=()
  
  for file in "${doc_files[@]}"; do
    if [ -f "$file" ]; then
      echo "   üìÑ Processing $file..."
      
      # Extract phase/status
      local current_phase=$(grep -i "current\|status\|phase\|working on" "$file" | head -1 | sed 's/^[#*-]\+\s*//' | sed 's/[:]\s*/: /')
      if [ -n "$current_phase" ] && [ -z "$phase" ]; then
        phase="$current_phase"
      fi
      
      # Extract completed items
      while IFS= read -r line; do
        if echo "$line" | grep -qi "completed\|done\|finished"; then
          local item=$(echo "$line" | sed 's/^[#*-]\+\s*//' | sed 's/completed[:]\?\s*//i')
          if [ -n "$item" ]; then
            completed+=("$item")
          fi
        fi
      done < "$file"
      
      # Extract todo/next items
      while IFS= read -r line; do
        if echo "$line" | grep -qi "todo\|next\|pending\|task"; then
          local item=$(echo "$line" | sed 's/^[#*-]\+\s*//' | sed 's/todo[:]\?\s*//i' | sed 's/next[:]\?\s*//i')
          if [ -n "$item" ]; then
            todos+=("$item")
          fi
        fi
      done < "$file"
      
      # Extract decisions
      while IFS= read -r line; do
        if echo "$line" | grep -qi "decision\|chose\|using\|decided"; then
          local item=$(echo "$line" | sed 's/^[#*-]\+\s*//')
          if [ -n "$item" ]; then
            decisions+=("$item")
          fi
        fi
      done < "$file"
    fi
  done
  
  echo "üîÑ Importing to Continuum..."
  
  # Import phase
  if [ -n "$phase" ]; then
    echo "   üìã Setting phase: $phase"
    curl -s -X POST http://localhost:8000/phase \
      -H "Content-Type: application/json" \
      -d "{\"phase\":\"$phase\"}" >/dev/null
  fi
  
  # Import completed items
  for item in "${completed[@]}"; do
    echo "   ‚úÖ Logging completed: $item"
    curl -s -X POST http://localhost:8000/log \
      -H "Content-Type: application/json" \
      -d "{\"notes\":\"$item\",\"type\":\"imported\"}" >/dev/null
  done
  
  # Import todos
  for item in "${todos[@]}"; do
    echo "   üìù Adding task: $item"
    curl -s -X POST http://localhost:8000/next \
      -H "Content-Type: application/json" \
      -d "{\"task\":\"$item\"}" >/dev/null
  done
  
  # Import decisions
  for item in "${decisions[@]}"; do
    echo "   üéØ Logging decision: $item"
    curl -s -X POST http://localhost:8000/log \
      -H "Content-Type: application/json" \
      -d "{\"notes\":\"$item\",\"type\":\"decision\"}" >/dev/null
  done
  
  echo ""
  echo "üéâ Import completed! Summary:"
  curl -s http://localhost:8000/summary | jq -r '
    "Phase: " + .current_phase,
    "Recent items: " + (.last_steps | length | tostring),
    "Next tasks: " + (.next_tasks | length | tostring)
  ' 2>/dev/null || echo "   Check status with: mem show --summary"
  
  echo ""
  echo "üìÅ Moving original files to .continuum-imported/ for safety..."
  
  # Create archive folder
  mkdir -p .continuum-imported
  
  # Move files to archive
  local moved_files=()
  for file in "${doc_files[@]}"; do
    if [ -f "$file" ]; then
      mv "$file" .continuum-imported/
      moved_files+=("$file")
      echo "   üì¶ Archived: $file ‚Üí .continuum-imported/"
    fi
  done
  
  echo ""
  echo "‚úÖ Import complete! Original files safely archived in .continuum-imported/"
  echo "   You can restore with: mv .continuum-imported/* ."
  echo "   Or delete archive when confident: rm -rf .continuum-imported/"
  echo ""
  echo "üöÄ Continuum is now your single source of truth!"
}

function auto_setup() {
  echo "üöÄ Setting up Continuum for: $(basename $(pwd))"
  
  # Initialize memory if not exists
  if [ ! -f "$MEM_FILE" ]; then
    echo "  üìù Initializing memory..."
    ~/dev/continuum/bin/mem init
  else
    echo "  ‚úÖ Memory already exists"
  fi
  
  # Install git hook if git repo exists
  if [ -d ".git" ] && [ ! -f "$HOOK_FILE" ]; then
    echo "  üîó Installing git commit hook..."
    cp "$CONTINUUM_HOOK" "$HOOK_FILE" 2>/dev/null && chmod +x "$HOOK_FILE"
    echo "  ‚úÖ Git hook installed"
  elif [ -d ".git" ]; then
    echo "  ‚úÖ Git hook already exists"
  else
    echo "  ‚ö†Ô∏è  No git repo found (hook not installed)"
  fi
  
  # Check for project documentation files and offer import
  check_for_import
  
  echo "  üìä Current status:"
  ~/dev/continuum/bin/mem show --summary
  echo
  echo "‚ú® Continuum ready! Use 'mem' commands or 'continuum start' for API server."
}

function start_server() {
  # Check if virtual env exists, create if not
  if [ ! -d "continuum-env" ]; then
    echo "üì¶ Creating virtual environment..."
    python3 -m venv continuum-env
    source continuum-env/bin/activate
    pip install -q fastapi uvicorn
  else
    source continuum-env/bin/activate
  fi
  
  echo "üåê Starting Continuum API server for: $(basename $(pwd))"
  echo "   Access at: http://127.0.0.1:8000"
  echo "   Docs at: http://127.0.0.1:8000/docs"
  echo "   Press Ctrl+C to stop"
  python ~/dev/continuum/server.py
}

function show_status() {
  if [ -f "$MEM_FILE" ]; then
    echo "‚úÖ Continuum active in: $(basename $(pwd))"
    ~/dev/continuum/bin/mem show --summary
  else
    echo "‚ùå Continuum not initialized. Run 'continuum' to set up."
  fi
}

case "$1" in
  init)
    ~/dev/continuum/bin/mem init
    ;;
  start)
    start_server
    ;;
  status)
    show_status
    ;;
  import)
    import_docs
    ;;
  help|--help|-h)
    show_help
    ;;
  "")
    auto_setup
    ;;
  *)
    echo "Unknown command: $1"
    show_help
    exit 1
    ;;
esac